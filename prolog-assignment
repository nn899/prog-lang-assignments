user(@john).
user(@mary).
user(@robert).
user(@alan).
user(@george).
user(@harry).


follows(@john,@mary).
follows(@mary,@robert).
follows(@robert,@alan).
follows(@alan,@george).
follows(@george,@harry).
follows(@john,@alan).


tweet(@john,t1,'hello world').
tweet(@alan,t12,'good day').
tweet(@john,t2,'good morning').
tweet(@mary,t3,'happy thanksgiving').
tweet(@mary,t4,'happy new year').
tweet(@robert,t5,'I am feeling happy').
tweet(@alan,t6,'now I am feeling sad').
tweet(@alan,t7,'merry christmas').
tweet(@robert,t8,'have a good day').
tweet(@george,t9,'it is a beautiful day').
tweet(@george,t10,'contradictions and predicaments').
tweet(@harry,t11,'predicates and clauses').
tweet(@harry,t12,'good night').

retweet(@john,t3).
retweet(@mary,t5).
retweet(@mary,t11).
retweet(@mary,t1).
retweet(@mary,t2).
retweet(@robert,t8).
retweet(@robert,t9).
retweet(@robert,t11).
retweet(@harry,t10).
retweet(@george,t7).
retweet(@alan,t9).
retweet(@alan,t11).
retweet(@george,t11).
retweet(@alan,t12).
retweet(@george,t12).

feedhelper(U,F,M,I) :- user(U), user(F), follows(U,F), tweet(F,I,M).
feedhelper(U,F,M,I) :- user(U), user(F), follows(U,F), retweet(F,I), tweet(_,I,M).

feed(U,M) :- uniquefeed(U,O),remove_ident(O,M).
uniquefeed(U,R) :- setof([I,F|M],feedhelper(U,F,M,I),R).
remove_ident([],[]).
remove_ident([[_|Y]|T1],[H2|T2]) :- Y=H2,remove_ident(T1,T2).

dm(@robert,@john,m1,'Hi there').
dm(@mary,@john,m2,'how are you').
dm(@george,@alan,m3,'good to see you').
dm(@harry,@alan,m4,'where have you been?').
dm(@george,@mary,m5,'hello Mary').
dm(@harry,@george,m6,'testing direct messages').
dm(@mary,@robert,m7,'thank you').
dm(@mary,@john,m8,'twitter : scala').
dm(@alan,@robert,m9,'twitter : prolog').

% The relation inbox/4 will not show any messages
% if follows(R,S) is not true even if there exists 
% a dm(S,R,I,M).
inbox(S,R,I,M) :- follows(R,S), dm(S,R,I,M).

search(K,U,M) :- tweet(U,_,M), atomic_list_concat(L,' ',M),member(K,L), writeln('match found').

% If A follows B and B follows C and C follows D 
% then intermediate(A,D,X) will give a list X containing
% [B,C].
intermediate(X,Y,[]) :- follows(X,Y).
intermediate(X,Y,[Z|P]) :- not(X == Y), follows(X,Z), intermediate(Z,Y,P), not(member(Z, P)).

% shortest is for getting the smallest set X of all 
% the sets generated by intermediate
shortest(A,B,Path) :-
   setof([P],intermediate(A,B,P),Set),
   Set = [_|_], % fail if empty
   minimal(Set,[Path]).

minimal([F|R],M) :- min(R,F,M).
% minimal path
min([],M,M).
min([[P,L]|R],[_,M],Min) :- L < M, !, min(R,[P,L],Min).
min([_|R],M,Min) :- min(R,M,Min).

isviral(S,I,R) :- intermediate(R,S,X), tweet(S,I,_), forall(member(A,X), retweet(A,I)).

% count_elem counts the number of elements in a list
count_elem([],0).
count_elem([_|L],N) :- count_elem(L,N1), N is N1 + 1.

% count_user counts the number of users who retweeted a specific tweet I
count_user(I,C) :- setof(U,retweet(U,I),R), count_elem(R,C).

% If we want to see the list of users too
% we can use the relation below 
% count_user(I,R,C) :-  setof(U,retweet(U,I),R), count_elem(R,C).

check(X,Y) :- X>=Y.

% The relation isviral/4 as below would check for a given numeric value M
isviral(S,I,R,M) :- isviral(S,I,R), intermediate(R,S,X), count_elem(X,C), check(C,M).

% isviral(S,I,R,M) :- isviral(S,I,R), intermediate(R,S,X), count_elem(X,C), M is C.
% answer 12
% Create your own Prolog relation that makes non-trivial use of the items
% above. Also briefly describe the relation in English.
% If S follows R and there is a tweet of S that R retweeted then famous_set will
% return such tweets as a singleton set.
famous_set(S,X) :- follows(S,R), tweet(S,I,M), retweet(R,I), setof(M,tweet(S,I,M),X). 

